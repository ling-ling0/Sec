---
layout: page
title: "networkbase"
permalink: /networkbase
---

网络安全相关基础内容, 即部分计算机网络的内容
### 网络模型
网络模型分为如下三种

![alt text](docs/images/netlayers.png)

**物理层**: 主要实现相邻节点之间比特流的传递,  在物理媒介(如光纤, 电缆, 无线信号等)上实现原始的数据传输, 尽可能屏蔽传输介质和物理设备的差异.

物理层的设备主要是集线器和中继器, 其主要作用是将信号进行放大和传输, 实现设备之间直接的信号传输. 其没有定向传送能力, 即信号的传递方向是固定的. 对于集线器, 其工作时在某个端口收到信号, 而后经过整形放大, 再将其转发给除输入端口之外的所有端口.

**数据链路层**: 主要实现帧在一段链路上或一个网络中进行传输, 实现封装成帧, 透明传输和差错检测. MAC地址和各种MAC协议如ALOHA协议, CSMA/CD协议, 滑动窗口系列协议等也都存在于数据链路层.

封装成帧指的是在网络层传递下来的数据中前后分别添加首部和尾部, 而后构造数据帧用于传递.

透明传输指的是无论数据在物理层上是什么样的比特组合, 都可以无差错的在这个链路中进行传输. 而透明传输的实现是依赖于封装成帧的, 在封装成帧的过程中, 首部和尾部存在**帧定界**的作用. 而接收方能从接收到的比特流中区分出各个帧的起始和结束, 也就是**帧同步**. 

差错检测中分为位错和帧错, 可以在数据链路层使用某些方法进行检测和纠正.

数据链路层为网络层提供三种服务: 无确认的无连接服务, 有确认的无连接服务, 有确认的面向连接服务. 不存在无确认的面相连接的服务.

以太网交换机工作在数据链路层, 其主要是识别帧头部并按照要求进行转发. 交换机能将网络分成多个冲突域, 按照需求进行转发. 

共享式以太网(集线器组网)和交换式以太网(交换机组网)的区别: 对于共享式以太网, 集线器将消息转发给其余所有端口, 随后收到消息的主机根据自己的MAC地址决定接受还是丢弃; 对于交换式以太网, 交换机收到帧后, 根据其中的目的MAC地址和自己的转发表决定转发给哪个端口(如果是广播帧则转发给除输入外所有端口), 发送给目标主机.

**网络层**: 网络层主要实现的是将一个分组从一台主机跨越多个网络和链路传输到目标主机. 这一过程主要包括分组转发和路由选择. 

在TCP/IP体系结构中, 网络层只向上提供简单灵活, 无连接的, 尽最大努力交付的数据报服务. 

IPv4地址: 共有32位, 分为五类地址. 

![alt text](images/IPv4addr.png)

其中部分地址存在特殊用处. 主机号全0表示网络本身, 如 202.98.174.0; 主机号全1表示本网络的广播地址; 127.x.x.x表示主机本身, 又称回环地址; 全0表示该网络上本主机; 全1表示整个网络的广播地址, 实际使用时受限于路由器对广播域的隔离等效于本网络的广播地址.

NAT(网络地址转换): 划分部分IP作为私有IP, 只用于LAN中, 不用于WAN连接. 私有IP分为三类: A:10.0.0.0~10.255.255.255; B:172.16.0.0~172.31.255.255; C:192.168.0.0~192.168.255.255. 每个私有网络需要有至少一个合法的外部IP, 用于接受外界信息并转发给网络内部主机.

IPv6是对IPv4的扩展, 其使用将地址长度扩大到128位, 显著缓解了IP地址不够用的问题.

网络层设备--路由器可以分割广播域

**传输层**: 传输层在网络层之上, 主要是为运行在不同主机上的进程之间提供逻辑通信. 在网络层提供了两种不同的传输协议, 即TCP协议和UDP协议.

TCP提供面向连接的可靠服务, UDP提供无连接的不可靠服务.

**TCP三次握手以及四次挥手**:

三次握手:
* 客户端主机发起连接请求, 设置SYN标志为1, 并随机选择一个序列号x发送. 发送后进入SYN_SENT状态.
* 服务器处于监听(LISTEN)状态, 接收到客户端发送的请求包, 为目标连接分配空间(这是[TCP洪水攻击](./networkattack.md/#tcp洪水攻击)的位置), 返回一个数据包, SYN和ACK设置为1, ack序列号为x+1, 随机选择一个序列号y发送. 发送之后进入SYN_RCVD状态.
* 客户端收到回复包, 客户端也为该连接分配空间, 设置ACK为1, SYN为0, ack序列号为y+1,序列号为x+1. 发送之后客户端进入到ESTABLISHED状态, 即连接成功. 此数据包可以开始携带数据了, 服务器接收到这个包之后也进入ESTABLISHED状态.

三次握手图解:

![alt text](images/handshake.png)

Q: 为什么握手需要三次? 而不是别的次数?

A: 一种理解是, 能够让双方都确认自己和对方的发送与接收能力的最少通讯次数:

    第一次发送时, 客户端确认了自己的发送能力, 服务器确定了对方的发送能力和自己的接收能力; 
    第二次发送时, 客户端确定了对方的发送能力和自己的接收能力, 同时对方能给出回复, 也就确定了对方的接收能力, 服务器确定了自己的发送能力. 此时客户端对于四种能力均确认好, 于是进入ESTABLISHED状态;
    第三次发送时, 服务器确定了对方的接收能力, 于是才进入到ESTABLISHED状态.

如果没有第三次握手的过程, 会在使用中出现问题. 如这样的一个情况: A发送的SYN包过了较长一段时间才到达B处, 但是此时已经超过了连接的时间, B依然回复正常, 但是A已经将该包抛弃了, 这就会使得B单方面建立连接, 浪费B的资源.

四次挥手:
* 在挥手之前双方均处于ESTABLISHED状态, 此时客户端提出结束连接, 发送FIN包, 其中FIN设置为1, 序列号为u, 发送之后进入到FIN-WAIT1状态, 等待服务器给出回答.
* 服务器收到FIN包, 知晓客户端请求结束连接, ACK设置为1, seq为v, ack序列号为u+1, 回复一个应答数据包, 同时自己进入CLOSE_WAIT状态, 会将剩下未传输结束的数据继续传输. 此时的客户端收到服务器答应结束的回复后进入FIN_WAIT2状态, 并继续接受服务器还未传输完的数据, 但是不再发送数据.
* 服务器发送了所有数据之后, 同样发送FIN包, FIN设置为1, ACK设置为1, seq为w, ack序列号仍为u+1, 因为这段时间内客户端没有发送任何数据包. 发送之后服务器进入到LAST-ACK状态.
* 客户端接收到这个FIN包之后意识到客户端也已经发送完数据, 回复ACK=1, seq=u+1, ack序列号为w+1的应答数据包, 随后进入到TIME-WAIT状态. 这个数据包被服务器接受, 服务器彻底关闭连接, 进入CLOSED状态. 而客户端需要再等待2MSL的时间后, 再进入CLOSED状态, 彻底结束连接.

四次挥手图解:

![alt text](images/handwave.png)

Q: 四次挥手中最重要的是TIME-WAIT状态, 为什么?(为什么存在TIME-WAIT状态?)

A: 这个状态保证服务器的FIN报文会被客户端接收到, 并且客户端的ACK报文也到达了服务器. 如果在2MSL时间内, 服务器没有收到对应的ACK, 客户端就会再次收到FIN报文, 这样避免了只有用户端结束而服务器端尚未结束的问题.

常见协议及其所属的层次:
![alt text](images/Protocols.png)